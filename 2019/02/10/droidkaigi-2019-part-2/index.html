<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="description" content="eneim | the simple, the best"><meta name="keyword" content="eneim"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="Df1Qt2ADt1yncYOOFgSQqKm6MBiEXc2W7D7hr26ErEU"><meta name="description" content="This is the first part in my series about my talk at DroidKaigi 2019. You can find the rest of them below:  Part 1 Part 2 (this post) Part 3 Part 4">
<meta name="keywords" content="Android,RecyclerView,ExoPlayer,2019,DroidKaigi">
<meta property="og:type" content="article">
<meta property="og:title" content="Droidkaigi 2019 (part 2)">
<meta property="og:url" content="https://ene.im/2019/02/10/droidkaigi-2019-part-2/index.html">
<meta property="og:site_name" content="eneim's log">
<meta property="og:description" content="This is the first part in my series about my talk at DroidKaigi 2019. You can find the rest of them below:  Part 1 Part 2 (this post) Part 3 Part 4">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://ene.im/2019/02/10/droidkaigi-2019-part-2/types_of_single_player.png">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:image" content="https://ene.im/js/lazyload-plugin/loading.svg">
<meta property="og:updated_time" content="2019-02-28T03:52:55.607Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Droidkaigi 2019 (part 2)">
<meta name="twitter:description" content="This is the first part in my series about my talk at DroidKaigi 2019. You can find the rest of them below:  Part 1 Part 2 (this post) Part 3 Part 4">
<meta name="twitter:image" content="https://ene.im/2019/02/10/droidkaigi-2019-part-2/types_of_single_player.png">
<meta name="twitter:creator" content="@ene__im"><title>Droidkaigi 2019 (part 2)</title><link rel="shortcut icon" href="/img/eneim.ico" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><link href="/styles/zoom.css" rel="stylesheet"><link href="/styles/youtube.css" rel="stylesheet"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">eneim</a></div><div class="about-me">the simple, the best</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">archives</a></li><li><a href="/atom.xml">rss</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/eneim"></span><a href="https://github.com/eneim" target="_blank" title="https://github.com/eneim">https://github.com/eneim</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="nam@ene.im"></span><span>nam@ene.im</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">Droidkaigi 2019 (part 2)</div><div class="date"># 2019/02/10</div><div class="content"><meta name="generator" content="Hexo 3.8.0"><p>This is the first part in my series about my talk at <a href="https://droidkaigi.jp/2019/" target="_blank" rel="noopener">DroidKaigi 2019</a>. You can find the rest of them below:</p>
<ul>
<li><a href="/2019/02/10/droidkaigi-2019-part-1/">Part 1</a></li>
<li><a href="/2019/02/10/droidkaigi-2019-part-2/">Part 2 (this post)</a></li>
<li><a href="/2019/02/10/droidkaigi-2019-part-3/">Part 3</a></li>
<li><a href="/2019/02/10/droidkaigi-2019-part-4/">Part 4</a></li>
</ul>
<a id="more"></a>
<h2 id="2-The-proposal"><a href="#2-The-proposal" class="headerlink" title="2. The proposal"></a>2. The proposal</h2><p>I would dedicate this whole post to share about my proposal about this topic: “ExoPlayer in RecyclerView”. The presentation I used at DroidKaigi is below:</p>
<script async class="speakerdeck-embed" data-id="b981bd5abcd44d228a8cc3717023a965" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>

<h4 id="2-1-Investigate-the-challenges"><a href="#2-1-Investigate-the-challenges" class="headerlink" title="2.1 Investigate the challenges"></a>2.1 Investigate the challenges</h4><p><strong>First</strong>, let’s start by investigating our challenges. I would like to start from the fullscreen playback experience.</p>
<p>In fact, the experience including user open a dedicated playback screen for one item from the list, I would like to call it <strong>Single Player</strong> instead of Fullscreen.</p>
<p>Let’s think about this experience. How many form factor of <strong>Single Player</strong> we have? Of course, it depends on how you design your App, but roughly thinking, there are 3 forms we can use to represent the <strong>Single Player</strong>:</p>
<ul>
<li>Same orientation Player</li>
<li>Multi windows state Player</li>
<li>Landscape Player</li>
</ul>
<img src="/2019/02/10/droidkaigi-2019-part-2/types_of_single_player.png">
<p>There may be more, for example Picture-In-Picture mode. But implement it is not trivial, I would like to spend other post for it.</p>
<p>Opening Single Player and back has the following challenges in term of UX:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- Opening Single Player has many chances for config changes</span><br><span class="line">- Handle config changes manually (= add manifest entry)</span><br><span class="line">  - Pros: no resource reloading, playback continuity done!</span><br><span class="line">  - Cons: no adaptive layout, or manually apply using if/else/while… (not me (>_<))< span><br><span class="line">  - Many config changes patterns = error prone</span><br><span class="line">- Handle config changes automatically (= no manifest entry)</span><br><span class="line">  - Pros: adaptive layout for each config</span><br><span class="line">  - Cons/Unresolved: playback continuity</span><br><!--))<--></span></pre></td></tr></tbody></table></figure>
<p>Let’s take an example of Facebook app to see how the experience works in practice:</p>
<div class="progress-images" style="width:960px"><div class="progress-images--placeholder" style="padding-bottom: 56.25%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/ui_pattern_facebook.png" data-thumb="/images/thumb/24396fbaf16e3750d4b4ca624d5180c6.png"></div>
<ol>
<li><p>User from homescreen click to an item and open its <strong>Single Player</strong> in the same orientation.</p>
</li>
<li><p>User from homescreen, rotate the phone. It will open the <strong>Single Player</strong> in landscape mode automatically.</p>
</li>
<li><p>User rotate the phone from “same orientation Single Player”. It will open the <strong>Single Player</strong> in landscape mode automatically.</p>
</li>
</ol>
<p>We can see that in 2. and 3., there is chance for configuration change.</p>
<p>Above, we discussed about the form factor of a Single Player. Below is common flow to open one:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- Open single player on new Activity</span><br><span class="line">- Open single player on Dialog (fullscreen, in same Activity)</span><br><span class="line">- Open in Fragment by replacing current one (in same Activity).</span><br></pre></td></tr></tbody></table></figure>
<p>Of course, there may be more, but it will end up asking us the same questions:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- How to open Single Player and keep the playback continuity?</span><br><span class="line">- How to come back and keep the playback continuity?</span><br></pre></td></tr></tbody></table></figure>
<p>So to summarize, our implementation should ends up answering the following questions:</p>
<ul>
<li>How we handle all the changes during opening Single Player and back from it?</li>
<li>How we ensure playback continuity?</li>
</ul>
<h4 id="2-2-Principle-strategy-and-Components"><a href="#2-2-Principle-strategy-and-Components" class="headerlink" title="2.2 Principle (strategy) and Components"></a>2.2 Principle (strategy) and Components</h4><p><strong>Next</strong>, let me talk about my Proposal, starting from the principles I would follow to design it:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- Balance UX and performance</span><br><span class="line">  - 2019 devices has more RAM than my Mac</span><br><span class="line">  - And more CPU cores too</span><br><span class="line">  - UX gain requries Performance loss</span><br><span class="line">- Avoid resource reloading as much as possible.</span><br><span class="line">  - No reload on config change</span><br><span class="line">- Well lifecycle control does the magic</span><br><span class="line">  - Design lifecycle flow if need</span><br></pre></td></tr></tbody></table></figure>
<p>To accomplish those principles, here is how I make it: (1) design a mechanism where an instance of our “playback” could survive across many changes, including configuration changes (the recreation of an Activity), as well as lifecycle change (from one Activity to another, or from a Fragment to another). (2) design a resource management mechanism such that, it would retain just enough amount of resource (eg: ExoPlayer instances). The definition of ‘enough amount’ would vary, below is mine:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- Max instance number = max number of Videos on screen at once</span><br><span class="line">  - Play then Pause video + still on screen = holds an Player instance.</span><br><span class="line">  - Play then Pause video + scrolled off screen → release Player instance to Global Pool.</span><br><span class="line">  - Release video = instance is stored in Pool for reuse.</span><br></pre></td></tr></tbody></table></figure>
<p>So, in this approach, the more videos you have on screen, the less performant the App will be.</p>
<p>One good point of my approach is that, it doesn’t force the client to follow this principle always, but it allows for customization that just need to meet some certain requirements.</p>
<p>Below is my explanation for (1): a mechanism to keep the playback continuity.</p>
<p>First, we need some components to make it happens:</p>
<ul>
<li><strong>Playable</strong>: a piece of resource, can be played. Example: an ExoPlayer instance</li>
<li><strong>Target</strong>: to which a <strong>Playable</strong> can be played on, the object to present the playback on. Eg: PlayerView (in ExoPlayer library)</li>
<li><strong>Playback</strong>: when a <strong>Playable</strong> is bound to a <strong>Target</strong>, it produces a <strong>Playback</strong>. <strong>Playback</strong> represents the connection of a <strong>Playable</strong> and <strong>Target</strong></li>
</ul>
<p>These components form a team and work together:</p>
<ul>
<li><strong>Playable</strong> ⇆ <strong>Target</strong> binding is unique, but not required<ul>
<li>Binding same target will produce same <strong>Playback</strong> instance.</li>
<li>Different <strong>Playable</strong>s bind to one <strong>Target</strong>: the later wins.</li>
<li>Not in bound <strong>Playable</strong> will be cleaned up eventually.</li>
</ul>
</li>
<li><strong>Playable</strong> must be bound to <strong>Target</strong> to be “noticed”</li>
<li><strong>Playback</strong> observes <strong>Target</strong>‘s behavior and trigger <strong>Playable</strong></li>
</ul>
<div class="progress-images" style="width:1280px"><div class="progress-images--placeholder" style="padding-bottom: 62.5%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_components_1.gif" data-thumb="/images/thumb/5467764390368ba0d8c2121cdc9387f9.gif"></div>
<p>The inspiration behind this model is the blow line fro ExoPlayer</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line">PlayerView.switchTargetView(player, <span class="literal">null</span>, playerView)</span><br></pre></td></tr></tbody></table></figure>
<p>Because these components belong to a team, we need something to manage that team. And in our App, there will be many teams (many lifecycles), we also need something to manage those teams:</p>
<ul>
<li><strong>Manager</strong>: manages <strong>Playback</strong> instances (also, acknowledge the Playable)<ul>
<li>Ensure <strong>Playback</strong> uniqueness</li>
<li>One Playable can belong to at-most one Manager</li>
</ul>
</li>
<li><strong>Global singleton</strong>: manages <strong>Manager</strong>s and <strong>Playable</strong>s<ul>
<li>Also manage low layer resources like ExoPlayer instances, Factories</li>
<li>Observe lifecycles and dispatch actions to <strong>Manager</strong>s</li>
</ul>
</li>
</ul>
<p>I just say that <strong>Playable</strong> is in a team managed by <strong>Manager</strong>, but in fact, this <em>guy</em> is like us, developers. We stay in this project and then move to other project on demand. <strong>Playable</strong> is what we use to create what I called <strong>Playback Continuity</strong> before. To demonstrate this, let’s move to <em>components’ lifespan</em> and a figure below:</p>
<p><strong>Compoent’s lifespan</strong></p>
<ul>
<li>Components stay alive as long as possible<ul>
<li><strong>Playable</strong>: contains only resource for playback, stays in Application lifecycle</li>
<li><strong>Target</strong>: View, stays in Activity/Fragment lifecycle</li>
<li><strong>Playback</strong>: min(<strong>Target</strong>, <strong>Playable</strong>), stays in Activity/Fragment lifecycle</li>
</ul>
</li>
<li><strong>Playable</strong> survives config changes</li>
<li><strong>Playable</strong> can survive lifecycle changes if need<ul>
<li>eg: from Activity to Activity</li>
</ul>
</li>
<li><strong>Manager</strong>, <strong>Playback</strong>: stay in Activity/Fragment lifecycle<ul>
<li>Do not survive config changes</li>
</ul>
</li>
</ul>
<p><strong>Component’s lifecycle in action</strong></p>
<div class="progress-images" style="width:1280px"><div class="progress-images--placeholder" style="padding-bottom: 62.5%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_components_2.gif" data-thumb="/images/thumb/f0e79f615acd4447a0231baa243ee241.gif"></div>
<p>With these components, the way we keep the playback continuity is as follow: by switching the Target of a Playable, we do not need to recreate it or reprepare it. So says our current Target A is in the list inside Fragment A, when we open <em>single player</em> for it in Fragment B (and the playback surface is Target B), we rebind the Playable from Target A to Target B. Done!</p>
<p>But wait, replacing Fragments will involve a lot of changes, including Fragment destroying and creating. So how our Playable survices those changes? Let move to <strong>cross-lifecycles</strong>.</p>
<p><strong>Cross-lifecycles</strong></p>
<p><strong>Cross-lifecycles</strong> is the behavior when something happens in a lifecycle and keeps happening in another lifecycle started by current one. For example: a Video playing inside Activity, if this App using new Activity for single player, the Video should be playing after opening single player Activity from current one.</p>
<p>There are many patterns of <strong>cross-lifecycles</strong>: </p>
<ul>
<li>Starting Activity from current Activity (in this case, old Activity will be stopped).</li>
<li>Replacing Fragment by another Fragment (in this case, old Fragment will have it View destroyed by default).</li>
<li>Opening a DialogFragment from current Fragment (in this case, old Fragment is still active).</li>
<li>Config change is a special scenario of <strong>cross-lifecycle</strong>, where the same Activity is recreated on demand.</li>
</ul>
<p>In my approach, keeping <strong>Playable</strong> survive through <strong>cross-lifecycle</strong> is equal to keeping <strong>playback continuity</strong>. We investigate <strong>cross-lifecycles</strong> patterns below, and ses how our components work with them?</p>
<h4 id="1-Configuration-changes"><a href="#1-Configuration-changes" class="headerlink" title="1. Configuration changes"></a>1. Configuration changes</h4><div class="progress-images" style="width:1280px"><div class="progress-images--placeholder" style="padding-bottom: 62.5%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_cross_lifecycles_1.gif" data-thumb="/images/thumb/e05e0c26d5cb080ede1f98e0c3a483dc.gif"></div>
<p>As you can see from the figure: once config change happens, the Activity will tell it to client via the call <code>isChangingConfigurations</code>. Catching that value, we will know if we should keep our Playables survive or release them. In case of config change, if after the creation, the Activity still use the Playable, we keep it in Global cache, and rebind it after the recreation. That way, our Playale will just keep playing.</p>
<h4 id="2-Starting-Activity-from-Activity"><a href="#2-Starting-Activity-from-Activity" class="headerlink" title="2. Starting Activity from Activity"></a>2. Starting Activity from Activity</h4><p>There is no <code>isChangingConfigurations</code> signal in this case. Instead, we follow the lifecycle callback of each. Says from Activity A, the client calls <code>startActivity</code> to start single player in Activity B. The figure below shows how we handle this case:</p>
<div class="progress-images" style="width:1280px"><div class="progress-images--placeholder" style="padding-bottom: 62.5%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_cross_lifecycles_2.gif" data-thumb="/images/thumb/d3e922b36e035a705ef8a8e5decda5ea.gif"></div>
<p>Yeah it is. In this scenario: after calling <code>startActivity</code> from Activity A to open Activity B, first Activity B will be created, then started, after that Activity will be stopped and destroyed. So in Activity B’s <code>onStart</code> or <code>onCreate</code>, it just needs to <em>take</em> the Playable from Activity A, this Playable will be unchanged, and our playback will keep playing continously.</p>
<h4 id="3-Replacing-Fragment-by-a-Fragment"><a href="#3-Replacing-Fragment-by-a-Fragment" class="headerlink" title="3. Replacing Fragment by a Fragment"></a>3. Replacing Fragment by a Fragment</h4><p>Consider the case: client open single player in Fragment B, using Activity’s <code>FragmentManager</code> to replace current Fragment A with it. Because Fragment represents the same lifecycle sequence with Activity, so we hope the same timeline above will be true for Fragment.</p>
<p>By default, it is not. Fragment A will be destroyed first before the creation of Fragment B. During the gap between a destruction and a creation, we have no clue to rely on, to keep our Playable alive.</p>
<p>But, we are lucky. Latest support Fragment library brings the method <a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/FragmentTransaction#setReorderingAllowed%28kotlin.Boolean%29" target="_blank" rel="noopener"><code>setReorderingAllowed</code></a> to live, which allow Fragment transaction to happen in the same way Activities’ lifecycle. So we have the same methodology to keep Playable alive across FragmentTransaction:</p>
<div class="progress-images" style="width:960px"><div class="progress-images--placeholder" style="padding-bottom: 56.25%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_cross_lifecycles_3.png" data-thumb="/images/thumb/503fcf24a70a04eabd06ec94951fafe7.png"></div>
<h4 id="4-Opening-DialogFragment-from-Fragment-Activity"><a href="#4-Opening-DialogFragment-from-Fragment-Activity" class="headerlink" title="4. Opening DialogFragment from Fragment/Activity"></a>4. Opening DialogFragment from Fragment/Activity</h4><p>There is no destruction in this scenario. We can simple <em>take</em> the Playable to play inside the DialogFragment.</p>
<p>I will explain about <em>taking the Playable</em> in detail later.</p>
<h4 id="Combine-those-scenarios"><a href="#Combine-those-scenarios" class="headerlink" title="Combine those scenarios"></a>Combine those scenarios</h4><p>Combining those scenarios we discussed above, we could keep a Playable alive through various lifecycle transition, which in turns, keep our playback continuity:</p>
<div class="progress-images" style="width:1280px"><div class="progress-images--placeholder" style="padding-bottom: 62.5%;"></div><img src="/js/lazyload-plugin/loading.svg" class="progress-images--original" data-original="/2019/02/10/droidkaigi-2019-part-2/kohii_cross_lifecycles_4.gif" data-thumb="/images/thumb/5f9ad2bd827cc934034a29d16cb510d5.gif"></div>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>As shown above, by understanding the <strong>cross-lifecycles</strong> behavior, and use it correctly, we can keep the playback play continuously, across various transition, including configuration changes.</p>
<p>In next part, I would like to show how my approach manage the playback resource, make it work together with the components I define in this part, and finally how we would combine all of them in our final goal: to make ExoPlayer works in RecyclerView with ease.</p>
</div><div class="tags"><a class="tag-link" href="/tags/2019/">2019</a><a class="tag-link" href="/tags/android/">Android</a><a class="tag-link" href="/tags/droidkaigi/">DroidKaigi</a><a class="tag-link" href="/tags/exoplayer/">ExoPlayer</a><a class="tag-link" href="/tags/recyclerview/">RecyclerView</a></div></section></div><div class="container"><ul class="nav"><li>previous: <a href="/2019/02/10/droidkaigi-2019-part-3/">Droidkaigi 2019 (part 3)</a></li><li>next: <a href="/2019/02/10/droidkaigi-2019-part-1/">Droidkaigi 2019 (part 1)</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-curry" target="_blank">Curry</a><span>.</span></div></footer><script src="/script/jquery.min.js"></script><script src="/script/transition.js"></script><script src="/script/zoom.js"></script><script src="/script/index.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-72567780-7', 'auto');
ga('send', 'pageview');</script><script src="/script/post.js"></script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>